"""
Error Handling Template
Generated by Archaeologist Agent
"""

import logging
import traceback
from datetime import datetime
from typing import Any, Callable, Optional, Dict
from functools import wraps

class ErrorHandlingTemplate:
    """
    Template for robust error handling
    """
    
    def __init__(self, component_name: str):
        self.component_name = component_name
        self.logger = logging.getLogger(f"error.{component_name}")
        self.error_count = 0
        self.error_history = []
        
    def log_error(self, error: Exception, context: Optional[Dict[str, Any]] = None):
        """Log error with context"""
        self.error_count += 1
        
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "error_type": type(error).__name__,
            "error_message": str(error),
            "traceback": traceback.format_exc(),
            "context": context or {},
            "component": self.component_name
        }
        
        self.error_history.append(error_info)
        self.logger.error(f"Error in {self.component_name}: {error}", extra=error_info)
        
    def retry_with_backoff(self, max_retries: int = 3, backoff_factor: float = 1.0):
        """Decorator for retry with exponential backoff"""
        def decorator(func: Callable):
            @wraps(func)
            def wrapper(*args, **kwargs):
                last_exception = None
                
                for attempt in range(max_retries + 1):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        last_exception = e
                        self.log_error(e, {"attempt": attempt + 1, "function": func.__name__})
                        
                        if attempt < max_retries:
                            delay = backoff_factor * (2 ** attempt)
                            time.sleep(delay)
                        else:
                            self.logger.error(f"All {max_retries + 1} attempts failed for {func.__name__}")
                            
                raise last_exception
            return wrapper
        return decorator
        
    def safe_execute(self, func: Callable, *args, default_return=None, **kwargs):
        """Safely execute function with error handling"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            self.log_error(e, {"function": func.__name__, "args": str(args)})
            return default_return
            
    def get_error_summary(self) -> Dict[str, Any]:
        """Get error summary statistics"""
        return {
            "component": self.component_name,
            "total_errors": self.error_count,
            "recent_errors": len([e for e in self.error_history 
                                 if (datetime.now() - datetime.fromisoformat(e["timestamp"])).total_seconds() < 3600])
        }

# Example usage:
# error_handler = ErrorHandlingTemplate("sms_client")
# 
# @error_handler.retry_with_backoff(max_retries=3)
# def send_sms(message):
#     # SMS sending logic
#     pass
